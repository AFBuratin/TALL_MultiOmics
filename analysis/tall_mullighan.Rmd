---
title: "T-ALL"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, tidy = TRUE)
WhereAmI <- "analysis"
omicsdir = "/sharedfs01/alessia/TALL_MultiOmics/Omics_data/"
outdir = "/sharedfs01/alessia/TALL_MultiOmics/analysis/"
## load libraries
require(parallel)
library(knitr)
library(cowplot)
library(tidyverse)
library(mixOmics)
library(amritr)
library(corrplot)
require(parallel)
library(sear)
library(UpSetR)
library(venn)
library(igraph)
library(ggraph)
library(ggalt)
library(RColorBrewer)
library(MOVICS)
library(dplyr)
library(data.table)
## load data
meta_Mull = read.csv(file.path(omicsdir, "meta_mull_complete.csv"))[-c(3,77,86),]
meta_Mull$groupA = fct_collapse(meta_Mull$condition,
             IMM = c("NKX2_1","LMO2_LYL1"),
             HOXA = "HOXA",
             TLX1 = "TLX1",
             TLX3 = "TLX3",
             TAL_LMO = c("LMO1/2", "TAL1", "TAL2"),
             Unknown = "Unknown"
)
mRNA_Mull = read.csv(file.path(omicsdir, "Mull_normalized_mRNA.csv"))
circRNA_Mull = read.csv(file.path(omicsdir, "Mull_normalized_circRNA.csv"))
mut_Mull = read.csv(file.path(omicsdir, "matrix_mullighan_mutation_count.csv"))
circ_to_genes <- as.data.frame(fread(file.path(omicsdir, "circ_to_genes.tsv")))
gene_to_circ <- as.data.frame(fread(file.path(omicsdir, "gene_to_circ.tsv")))
make.dt = function(mat){
  dt = as.matrix(mat[,-1])
  rownames(dt) = mat[,1]
  return(dt)
}
mu.data = list(mut.status = t(mut_Mull[meta_Mull$sample,]),
               mRNA.expr = make.dt(mRNA_Mull[,c("X", meta_Mull$sample)]),
               circRNA.expr = make.dt(mat = circRNA_Mull[,c("X", meta_Mull$sample)]))
ggplot(meta_Mull, aes(groupA, fill=groupA)) +
  geom_bar()+
  scale_fill_manual(values = setNames(c("#FFA500", "#FF00FF", "#FFD700", "#C71585", "#FF4500", "#bcbcbc"),
                                       nm=levels(annCol$Subgroups))) + theme_minimal()



meta_Mull %>%
    dplyr::count(groupA) %>%
    dplyr::mutate(Subgroups = fct_reorder(groupA, n, .desc = TRUE)) %>%
    ggplot(aes(x = Subgroups, y = n, fill = Subgroups)) + geom_bar(stat = 'identity') + scale_fill_manual(values = setNames(c("#FFA500", "#FF00FF", "#FFD700", "#C71585", "#FF4500", "#bcbcbc"),
                                       nm=levels(annCol$Subgroups))) + theme_minimal() + xlab("") + ylab("") +
  theme(axis.text.x = element_text(size=15, angle = 30, hjust = 1),
        axis.text.y = element_text(size=15),
        legend.text = element_text(size=15))
```

# Analysis 1: Comparison of clusterization performance between joint Dimension Reduction (jDM) approaches using mRNA, circRNA and mutation status

## Elite feature selection 

```{r include=FALSE}
# scenario: 
# considering we are dealing with continuous data and use pca to select elites
tmp       <- mu.data$mRNA.expr # get expression data
elite.mRNA <- getElites(dat       = tmp,
                       method    = "sd",
                       elite.num = 1000)
elite.mRNA <- getElites(dat       = tmp,
                       method    = "mad",
                       elite.num = 1000)
tmp       <- mu.data$circRNA.expr # get expression data
statistic <- apply(tmp, 1, mad)
names(statistic) <- rownames(tmp)
statistic %>% as.data.frame() %>% ggplot(aes(x=.)) + 
  geom_density()

elite.circRNA <- getElites(dat       = tmp,
                       method    = "mad",
                       elite.num = 1000)
dim(elite.circRNA$elite.dat) 
mu.data = list(mut.status = t(mut_Mull[meta_Mull$sample,]),
               mRNA.expr = elite.mRNA$elite.dat,
               circRNA.expr = elite.circRNA$elite.dat)
# save(mu.data, file = file.path(outdir, "mu.dataN83Ns1000.rda"))
```

## Choice of K clusters

Basically, we would like to discretize T-ALL patients according to three omics data: mRNA, circRNA and mutation status of selected genes. First we identify the T-ALL subtype (TS) by using one or multiple clustering algorithms; if multiple clustering algorithms are specified, we will perform a consensus clustering based on different subtyping results in order to derive stable and robust subtypes. Second, after having subtypes we will exploit the heterogeneity of subtypes from as many angles as possible. Third, each subtype should have a list of subtype-specific biomarkers for reproducing such subtype in external cohorts. 

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# identify optimal clustering number (using Cluster Prediction Index (CPI) from IntNMF)
optk.brca <- MOVICS::getClustNum(data        = mu.data,
                         is.binary   = c(T,F,F), # note: the 3th data is somatic mutation which is a binary matrix
                         try.N.clust = 2:5, # try cluster number from 2 to 8
                         fig.path = outdir, 
                         fig.name    = "CLUSTER NUMBER OF T-ALL")
```

## perform multiple clustering

```{r eval=FALSE, include=FALSE}

# perform multi-omics integrative clustering with the rest of 9 algorithms
muic.res.list <- getMOIC(data        = mu.data,
                         methodslist = list("LRAcluster", "SNF",
                                            "MoCluster", "IntNMF", "CIMLR"),
                         N.clust     = 2,
                         type        = c("binomial", "gaussian", "gaussian"))
# save moic.res.list to local path
# save(muic.res.list, file = file.path(outdir, "muiN83Ns1000K2.res.list.rda"))
```

To improve the clustering robustness we can borrow the idea of consensus ensembles for later integration of clustering

```{r}
# load(file.path(outdir, "muiN83K2.res.list.rda"))
cmoic.tall <- MOVICS::getConsensusMOIC(moic.res.list = muic.res.list,
                               fig.name      = "CONSENSUS HEATMAP",
                               distance      = "euclidean",
                               linkage       = "complete", showID = F, 
                               fig.path = outdir)
getSilhouette(sil      = cmoic.tall$sil, # a sil object returned by getConsensusMOIC()
              fig.path = getwd(),
              fig.name = "SILHOUETTE",
              height   = 5.5,
              width    = 5)
```

### join Dimension Reduction (jDR): unsupervised clustering of patients according to joint decomposition

```{r}
### iClsuter
iClusterBayes.res <- getiClusterBayes(data        = mu.data,
                                      N.clust     = 2,
                                      type        = c("binomial","gaussian","gaussian"),
                                      n.burnin    = 1800,
                                      n.draw      = 1200,
                                      prior.gamma = c(0.5, 0.5, 0.5),
                                      sdev        = 0.05,
                                      thin        = 3)
ConsensusClustering.res = getConsensusClustering(data = mu.data, 
                       N.clust = 2,
                       reps = 1000, pItem = 0.8, clusterAlg = "hc", finalLinkage = "average", distance = "pearson")

factors_icluster<-as.matrix(t(iClusterBayes.res$fit$meanZ))
iClusterBayes.res$fit

### intNMF
library(IntNMF)
factorizations_intnmf <- nmf.mnnals(dat = lapply(mu.data, function(x) t(x)), k = 2)
factors_intNMF <- as.matrix(factorizations_intnmf$W)
intNMF.clusters = as.matrix(factorizations_intnmf$clusters)
colnames(factors_intNMF) <- 1:3
metagenes_intNMF <- list()
for(j in 1:length(mu.data)){
  metagenes_intNMF[[j]]<-t(factorizations_intnmf$H[[j]])
  rownames(metagenes_intNMF[[j]])<-rownames(mu.data[[j]])
  colnames(metagenes_intNMF[[j]])<-1:2
}

### SNF
library(SNFtool)
  alpha=0.5
  T.val=30
  num.neighbors = round(ncol(mu.data[[1]]) / 10)
  similarity.data = lapply(mu.data, function(x){
    SNFtool::affinityMatrix(SNFtool::dist2(as.matrix(t(scale(x))), as.matrix(t(scale(x)))), 
                                                                   num.neighbors, alpha)
    })
  if (length(similarity.data) == 1) {
    W = similarity.data[[1]]
  } else {
    W = SNFtool::SNF(similarity.data, num.neighbors, T.val)  
  }
  
  num.clusters = SNFtool::estimateNumberOfClustersGivenGraph(W, 2:7)[[2]]  
  clustering = SNFtool::spectralClustering(W, num.clusters)
table(cmoic.tall$clust.res$clust)
  # num.cons = ConsensusClusterPlus::ConsensusClusterPlus(d = W, reps = 1000, pItem = 0.8, finalLinkage = "average", distance = "pearson")
  # 
  # snf.clustering = num.cons[[2]]$consensusClass
  # names(snf.clustering) = colnames(similarity.data$mut.status)
  
  ### MCCA
library(PMA)
library(cluster)
get.clustering.silhouette <- function(raw.data, clustering) {
  sils = c()
  for (i in 1:length(raw.data)) {
    x = raw.data[[i]]
    distmatrix = SNFtool::dist2(as.matrix(t(x)),as.matrix(t(x)))
    sil = cluster::silhouette(clustering, dmatrix = distmatrix)[,3]
    sils = c(sils, mean(sil))
  }
  return(mean(sils))
}
get.elbow <- function(values, is.max) {
  second.derivatives = c()
  for (i in 2:(length(values) - 1)) {
    second.derivative = values[i + 1] + values[i - 1] - 2 * values[i]
    second.derivatives = c(second.derivatives, second.derivative)
  }
  print(second.derivatives)
  if (is.max) {
    return(which.max(second.derivatives) + 1)
  } else {
    return(which.min(second.derivatives) + 1)
  }
}
omics.transposed = lapply(mu.data, t)
cca.ret = PMA::MultiCCA(omics.transposed, 
                        ncomponents = 4)
sample.rep = omics.transposed[[2]] %*% cca.ret$ws[[2]]
  
explained.vars = sapply(1:4, 
                        function(i) sum(unlist(apply(sample.rep[1:i,,drop=F], 2, var))))
dimension = get.elbow(explained.vars, is.max=F)
  print(dimension)
  sample.rep = sample.rep[,1:dimension]
  sils = c()
  clustering.per.num.clusters = list()
  for (num.clusters in 2:4) {
    cur.clustering = kmeans(sample.rep, num.clusters, iter.max=100, nstart=30)$cluster  
    sil = get.clustering.silhouette(list(t(sample.rep)), cur.clustering)
    sils = c(sils, sil)
    clustering.per.num.clusters[[num.clusters - 1]] = cur.clustering
  }
  # NOTE: the next line contains an error. We mistakenly selected the minimal rather maximal silhouette.
  # See more details in: http://acgt.cs.tau.ac.il/multi_omic_benchmark/download.html.
  cca.clustering = clustering.per.num.clusters[[2]]
  # cca.clustering = clustering.per.num.clusters[[2]]

  ###MCIA
  library(omicade4)
  omics_pos<-list()
  for(j in 1:length(mu.data)){
    if(min(mu.data[[j]])<0){
      omics_pos[[j]]<-mu.data[[j]]+abs(min(mu.data[[j]]))
    }else{
      omics_pos[[j]]<-mu.data[[j]]
    }
    omics_pos[[j]]<-omics_pos[[j]]/max(omics_pos[[j]])
  }
  factorizations_mcia<-mcia(omics_pos, cia.nf = 5)

  factors_mcia<-as.matrix(factorizations_mcia$mcoa$SynVar)
  metagenes_mcia<-list()
  for(j in 1:length(mu.data)){
    metagenes_mcia[[j]]<-as.matrix(factorizations_mcia$mcoa$axis[1:dim(mu.data[[j]])[1],])
    rownames(metagenes_mcia[[j]])<-rownames(mu.data[[j]])
    colnames(metagenes_mcia[[j]])<-1:5
  }

  sils = c()
  clustering.per.num.clusters = list()
  for (num.clusters in 2:5) {
    cur.clustering = kmeans(factors_mcia, num.clusters, iter.max=100, nstart=30)$cluster  
    sil = get.clustering.silhouette(list(t(factors_mcia)), cur.clustering)
    sils = c(sils, sil)
    clustering.per.num.clusters[[num.clusters - 1]] = cur.clustering
  }
  # NOTE: the next line contains an error. We mistakenly selected the minimal rather maximal silhouette.
  # See more details in: http://acgt.cs.tau.ac.il/multi_omic_benchmark/download.html.
  mcia.clustering = clustering.per.num.clusters[[which.min(sils)]]
  # cca.clustering = clustering.per.num.clusters[[2]]
  table(mcia.clustering)
```

```{r include=FALSE}
## Factor representation
factors_data <- as.data.frame(sample.rep)

### Plotting the cluster models onto JDR

factors_data$cl = factor(mcia.clustering[rownames(factors_data)])
factors_data$cl = factor(cmoic.tall$clust.res$clust)
  plot(factorizations_mcia, axes=1:2, phenovec=cmoic.tall$clust.res$clust, sample.lab=FALSE, df.color=1:3)
topVar(factorizations_mcia, axis = 2)

# factors_data$cl = as.factor(cmoic.brca$clust.res$clust[match(rownames(factors_data), cmoic.brca$clust.res$samID)])
library(ggrepel)
cl_meta = merge(meta_Mull, factors_data, by.y = "row.names", by.x = "sample")
table(cl_meta$groupA, cl_meta$cl)
merge(meta_Mull, factors_data, by.y = "row.names", by.x = "sample") %>% 
  ggplot(aes_string(x="V1", y="V2", color="cl", shape = "groupA")) +
  geom_point(size=3) +
  guides(colour=guide_legend(override.aes=list(size=3))) +
  # geom_text_repel(aes(label = sample),
  #                 hjust = 0.5, vjust = 1) +
  xlab("Comp 1") + ylab("Comp 2") +
  ggtitle("") +
  theme_light(base_size=11) +
  theme(axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        legend.direction = "horizontal", 
        legend.position = "bottom",
        legend.box = "horizontal")

```

```{r}
# set color for each omics data
# if no color list specified all subheatmaps will be unified to green and red color pattern
mRNA.col   <- c("#00FF00", "#008000", "#000000", "#800000", "#FF0000")
circRNA.col <- c("#6699CC", "white"  , "#FF3C38")
mut.col    <- c("grey90" , "black")
col.list   <- list(mut.col, mRNA.col, circRNA.col)

# data normalization for heatmap
rownames(mu.data$mut.status) = paste0(rownames(mu.data$mut.status),"_mut")
rownames(mu.data$circRNA.expr) = paste0("circ", gene_to_circ$gene_name[match(rownames(mu.data$circRNA.expr), gene_to_circ$circ_id)],"(",rownames(mu.data$circRNA.expr),")")

plotdata <- getStdiz(data       = mu.data,
                     halfwidth  = c(NA,2,2), # no truncation for mutation
                     centerFlag = c(F,T,T), # no center for mutation
                     scaleFlag  = c(F,T,T)) # no scale for mutation

annCol    <- meta_Mull[,c("groupA", "ETP.status", "Gender"), drop = FALSE]
annCol$groupA = as.factor(annCol$groupA)
annCol$Gender[which(is.na(annCol$Gender))] = "Unknown"
annCol$Gender = factor(annCol$Gender)
levels(annCol$Gender)
annCol$ETP.status[is.na(annCol$ETP.status)] = "Unevaluable"
annCol$ETP.status[annCol$ETP.status=="N/A"] = "Unevaluable"

annCol$ETP.status = factor(annCol$ETP.status, levels = c("ETP", "nearETP", "notETP", "Unevaluable"), ordered = T)

rownames(annCol) = meta_Mull$sample
colnames(annCol) = c("Subgroups", "ETP", "Gender")
library(colorspace)
annColors <- list(Subgroups  = setNames(c("#FFA500", "#FF00FF", "#FFD700", "#C71585", "#FF4500", "#bcbcbc"), 
                                     # qualitative_hcl(length(levels(annCol$groupA)), "Dark 3"),
                                       nm = levels(annCol$Subgroups)),
                  Gender = setNames(c("#f678a7","#62aec5","#bcbcbc"),
                                    nm = levels(annCol$Gender)),
                  ETP = setNames(c("#C87A8A", "#909646", "#00A396", "#bcbcbc"), #qualitative_hcl(length(levels(annCol$ETP.status)), "Dark 2"),
                                       nm = levels(annCol$ETP)))
# clust.dt = data.frame(samID = colnames(W), 
#                       clust = clustering)
# rownames(clust.dt) = clust.dt$samID
circRNA_loadigs = as.data.frame(diablo.plot$loadings$circRNA.expr[diablo.plot$loadings$circRNA.expr[,1]!=0,])
circRNA_loadigs$circID = rownames(circRNA_loadigs)
top_circ = circRNA_loadigs %>% data.table() %>% dplyr::arrange(desc(abs(comp1))) %>% dplyr::select(circID)

mRNA_loadigs = as.data.frame(diablo.plot$loadings$mRNA.expr[diablo.plot$loadings$mRNA.expr[,1]!=0,])
mRNA_loadigs$mRNAID = rownames(mRNA_loadigs)
top_gene = mRNA_loadigs %>% data.table() %>% dplyr::arrange(desc(abs(comp1))) %>% dplyr::select(mRNAID)
feat = list(mutations = rownames(diablo.plot$loadings$mut.status[diablo.plot$loadings$mut.status[,1]!=0,])[1:5],
                  mRNA = top_gene$mRNAID[1:10],
                  circRNA = top_circ$circID[1:10])
lapply(feat, length)
clust.dt = cmoic.tall$clust.res
# comprehensive heatmap (may take a while)
MOVICS::getMoHeatmap(data         = plotdata,
             row.title     = c("Mutation","mRNA", "circRNA"),
             is.binary     = c(T,F,F), # the 4th data is mutation which is binary
             legend.name   = c("Mutated","mRNA.std", "circRNA.std"),
             clust.res     = clust.dt,#cmoic.brca$clust.res; muic.res.list$SNF$clust.res, # cluster results
             clust.dend    = NULL, # no dendrogram
             clust.dist.row = c("pearson", 
        "euclidean", "euclidean", "euclidean", "euclidean", "euclidean"), 
    clust.method.row = c("average", "ward.D2", "ward.D2", "ward.D2", 
        "ward.D2", "ward.D2"),
             show.rownames = c(F,F,F), # specify for each omics data
             show.colnames = FALSE, # show no sample names
             annRow        = feat, # mark selected features
             color         = col.list,
             annCol        = annCol, # annotation for samples
             annColors     = annColors, # annotation color
             width         = 10, # width of each subheatmap
             height        = 5, # height of each subheatmap
             fig.name      = "COMPREHENSIVE HEATMAP OF CONSENSUS CLUSTERING")
```

# Analysis 2: identified known and novel multi-omics biomarkers of the previously estimated subtypes - using mRNA, circRNAs and mutations

We now try to identify novel biomarkers in addition to biomarkers with known biological associations using a case study of T-ALL patients. We characterize and predict the novel clustering of T-ALL subtypes. 
We used a multivariate dimension reduction method that seeks for latent components – linear combinations of variables from each omics dataset, that are maximally correlated as specified by a design matrix. The identification of a multi-omics panel is obtained with l1 penalties in the model that shrink the variable coefficients defining the components to zero.

## Number of samples and variables per dataset

```{r, results = 'hide'}
Y <- paste0("CS", cmoic.tall$clust.res$clust)
names(Y) <- rownames(cmoic.tall$clust.res)
table(Y)
X <- lapply(mu.data, function(x) t(x))
all(names(Y) == rownames(X[[1]]))
all(names(Y) == rownames(X[[2]]))
all(names(Y) == rownames(X[[3]]))
```

```{r}
sapply(X, dim) %>% 
  as.data.frame %>% 
  mutate(Attribute = c("Number of Samples", "Number of features"))
```

## Clustering breakdown

```{r}
table(Y)
```

## Tuning of models using 3 dataset

The optimal multi-omics biomarker panel size was identified using a grid approach where, for any given combination of variables, we assessed the classification performance using a 5-fold cross-validation repeated 10 times.

```{r}
## design matrix
design <- matrix(0.1, nrow = length(X), ncol = length(X))
rownames(design) <- colnames(design) <- names(X)
diag(design) <- 0

test.keepX = list(mut.status = c(seq(1, 23, 5)),
                  mRNA.expr = c(seq(5,100,20)),
                  circRNA.expr = c(seq(5,100,20)))
tune = tune.block.splsda(X = X, Y = Y, ncomp = 5, 
                         test.keepX = test.keepX,
                         dist = "centroids.dist",
                         design = design, validation = "Mfold", folds = 5,
                         nrepeat = 10)
# saveRDS(tune, file.path(outdir, "tallPanel_tune_caseStudyK2N83Ns1000.rds"))
tune <- readRDS(file.path(outdir, "tallPanel_tune_caseStudyK2N83Ns1000.rds"))
```

## Optimal model

```{r, results='hide'}
## check rownames ordering
all(rownames(tune$error.rate) == rownames(tune$error.rate.sd))
```

```{r}
dt = data.frame(keepX = rep(rownames(tune$error.rate), 5), 
  meanError = as.numeric(tune$error.rate), 
  sdError = as.numeric(tune$error.rate.sd),
  comp = rep(paste0("comp", 1:5), each=nrow(tune$error.rate))) %>% 
  mutate(comp=factor(comp), keepX=factor(keepX)) %>% 
  group_by(keepX, comp) %>% 
  arrange(desc(meanError),.by_group = T)
# Calculate first minima for each Type
m1_intercept <- dt[which(dt$comp == "comp1"), ][which.min(dt[which(dt$comp == "comp1"), ]$meanError),]
m2_intercept <- dt[which(dt$comp == "comp2"), ][which.min(dt[which(dt$comp == "comp2"), ]$meanError),]
m3_intercept <- dt[which(dt$comp == "comp3"), ][which.min(dt[which(dt$comp == "comp3"), ]$meanError),]
m4_intercept <- df[which(df$Type == m2), ][which.min(df[which(df$Type == m2), ]$Value),]
m5_intercept <- df[which(df$Type == m2), ][which.min(df[which(df$Type == m2), ]$Value),]
# group_by(comp) %>% 
  # filter(meanError == min(meanError)) %>% 
  # filter(sdError == min(sdError)) %>% 
dt.min = dt %>% group_by(comp) %>% filter(meanError == min(meanError)) %>% 
  filter(sdError == min(sdError)) 
dt.min$comp = factor(dt.min$comp, levels = c("comp1", "comp2", "comp3", "comp4", "comp5"), ordered = T)
dt.min = dt.min[order(dt.min$comp),]
dt.min$keepX = factor(dt.min$keepX, levels = c("11_25_85", "16_5_65", "1_5_5", "21_5_5", "1_45_5"), ordered = T)

dt.min %>% ggplot(aes(x = reorder(keepX, comp), y= meanError, color = comp)) +
  # facet_wrap(~comp, scales = "free_x") +
       # geom_line() + 
  geom_point(size = 4) + 
       geom_errorbar(aes(ymin = meanError-sdError, ymax= meanError + sdError), 
         width=.5, position=position_dodge(0.05)) + 
  scale_color_discrete_sequential(palette = "Red-Blue", rev = F) + 
  theme_classic() +
  theme(text = element_text(size=16),
        axis.text.x = element_text(size = 18),
        axis.text.y = element_text(size = 16)) + 
  labs(title="Optimal combination for each Dimension", y="Balanced Error Rate (BER, 10X5-fold cross-validation)", x = "") 

dt %>%  filter(comp%in%c("comp1")) %>% 
  ggplot(aes(x = keepX, y = meanError, color=comp)) + 
  geom_line(aes(colour = comp, group = comp)) + 
  geom_vline(aes(xintercept=m1_intercept$keepX, color=m1_intercept$comp)) +
    geom_vline(aes(xintercept=m2_intercept$keepX, color=m2_intercept$comp)) +
    geom_vline(aes(xintercept=m3_intercept$keepX, color=m3_intercept$comp)) +
  theme_classic() +
  xlab("") +
  ylab("Balanced Error Rate (BER, 10X5-fold cross-validation)") +
  theme(text = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        axis.text.x =  element_blank())

plot(MyPerf.bac.plsX, col = color.mixo(5:7), sd = TRUE, legend.position = "horizontal")

```

### optimal keepX

```{r}
tune$choice.keepX
```

The optimal multi-omics panel consisted of 84 mRNA, 142 circRNAs, 22 mutations selected across five components with a balanced error rate of 12±1.5%. 

## estimated Model cv error rates
The centroids distance measure was used to compute the error rate. 

```{r}
# DIABLO full
keepX = tune$choice.keepX[names(X)]
# modName="DIABLO_full"
# diabloMod <- block.splsda(X = X, Y = Y, ncomp = 3, keepX = keepX, scheme = "centroid", design = design)  ## model fitting
# cv <- perf(diabloMod, validation = "Mfold", folds = 5, nrepeat = 10)  ## cross-validation
# ## Training error
# train <- data.frame(mean_err = cv$MajorityVote.error.rate$centroids.dist["Overall.BER", 3],
#                     sd_err = cv$MajorityVote.error.rate.sd$centroids.dist["Overall.BER", 3]) %>%
#   mutate(cohort = "train", modName = modName)
# 
# panels <- data.frame(panelLength = sapply(keepX, sum),
#                      dataset = names(sapply(keepX, sum)),
#                      modName = modName)
# 
# diablofull_perf = list(error=train, panels=panels)
# saveRDS(diablofull_perf, file.path(outdir, "talldiablofullN83K2_perf.rds"))
diablofull_perf <- readRDS(file.path(outdir, "talldiablofullN83K2_perf.rds"))
diablofull_perf
```

## run model - with optimal keepX

```{r}
## design matrix
ncomp <- 5
keepX = tune$choice.keepX
# diablo = block.splsda(X = X, Y = Y, ncomp = ncomp, keepX = keepX, design = design)
# saveRDS(diablo, file.path(outdir, "talldiabloSelN83K2Ns1000_perf.rds"))
diablo = readRDS(file.path(outdir, "talldiabloSelN83K2Ns1000_perf.rds"))
```

### Number of variables of each omic-type in the panel

```{r}
diabloPanel <- mapply(function(x, y, z, w, k){
  c(x, y, z, w, k)
}, x = lapply(mixOmics::selectVar(diablo, comp = 1)[-5], function(i) unlist(i[[1]])),
   y = lapply(mixOmics::selectVar(diablo, comp = 2)[-5], function(i) unlist(i[[1]])),
   z = lapply(mixOmics::selectVar(diablo, comp = 3)[-5], function(i) unlist(i[[1]])),
w = lapply(mixOmics::selectVar(diablo, comp = 4)[-5], function(i) unlist(i[[1]])),
k = lapply(mixOmics::selectVar(diablo, comp = 5)[-5], function(i) unlist(i[[1]])))
sapply(diabloPanel, length)
## only keep unique features
diabloPanel <- lapply(diabloPanel, unique)
```

## overlap between the diablo panel features (mutations, mRNA,circRNA) and with curated databases

```{r}
# driverdbv2 <- read.delim(paste0(WhereAmI, "disease_collections/driverdbv2.txt"), header = FALSE) %>% 
#   as.matrix %>% 
#   as.character()
# mircancer <- read.delim(paste0(WhereAmI, "disease_collections/miRCancerOctober2017.txt"), header = FALSE)
# mircancer <- mircancer[grep("breast", tolower(as.character(mircancer$V2))), "V1"] %>% as.character() %>% unique()
# molsigdb <- collections[grep("BREAST", collections$geneset), "members_mrna"] %>% unlist %>% unique
# omim0 <- read.delim(paste0(WhereAmI, "disease_collections/OMIM_Disease.txt"), header = FALSE)
# omim <- apply(omim0[, -1], 1, function(i){
#     x <- as.character(as.matrix(i))[as.character(as.matrix(i)) != ""]
#     x[!is.na(x)]
#   })
# names(omim) <- as.character(omim0[,1])
# omim <- omim[grep("breast", names(omim), value = TRUE)] %>% 
#   unlist %>% unique

dbLgL = read.csv("/sharedfs01/alessia/TALL_MultiOmics/disease_collections/dbLgL.csv")
leukemia_genes = list(DIABLO = input, #unlist(diabloPanel$mRNA.expr),
                  dbLgL = dbLgL$GeneSymbol)
venn(leukemia_genes, ilab=TRUE, zcolor = "style")
leukemiaDatabase <- data.frame(database = rep(c("dbLgL"), c(length(dbLgL))),
  feature = c(dbLgL))

panel.net = list(mRNA.expr = input.mRNA, 
                 circRNA.expr = circRNA_Sel_FC_CS1vsCS2$HG[match(input.circ, circRNA_Sel_FC_CS1vsCS2$SYMBOL)])
```

## Feature Plot

This panel identified many variables with previously known associations with ALL, as assessed by looking at the overlap between the panel features and gene sets related to ALL based on the dbLgL [23]. 
The feature plot depicts the variable contributions of each omics-type indicated by their loading weight (variable importance). Variables not found in any database may represent novel biomarkers of T-ALL.

```{r brcaPanel_features, fig.path='Figures/', dev='png', fig.width = 10, fig.height=13}
databases <- c("No overlap", "dbLgL")
featurePlot = function(panel, omicName, database){
  Dat <- rbind(mixOmics::selectVar(diablo, comp = 1)[[omicName]][["value"]], 
  mixOmics::selectVar(diablo, comp = 2)[[omicName]][["value"]],
  mixOmics::selectVar(diablo, comp = 3)[[omicName]][["value"]],
  mixOmics::selectVar(diablo, comp = 4)[[omicName]][["value"]],
  mixOmics::selectVar(diablo, comp = 5)[[omicName]][["value"]]) %>% 
  data.frame() %>% 
  mutate(dataset = omicName,
         feature = gsub(";", "\n", rownames(.)),
         value.var = abs(value.var)) %>% 
  group_by(dataset) %>% 
  arrange(value.var) %>% 
  mutate(feature = factor(as.character(feature), feature))
  Dat$database <- sapply(as.character(Dat$feature), function(i){
  paste(unique(as.character(subset(leukemiaDatabase, feature.GeneSymbol %in% unlist(strsplit(i, ";")))$database)), collapse = "_")})
  Dat$database[Dat$database == ""] <- "No overlap"
  Dat$database <- factor(as.character(Dat$database), databases)
  
  Segment <- geom_segment(aes(yend = feature, color = database), xend = 0, size = 0.8)
  Point <- geom_point(size = 2, aes(color = database, fill = database)) 
  Theme <- theme_bw() + theme(panel.grid.major.y = element_blank(),legend.justification = c(1, 0.5))
  
  ggplot(Dat, aes(x = value.var, y = feature)) +
 	Segment +
 	Point +
	Theme +
	ggtitle(omicName) + ylab("Variables")
}
p1 <- featurePlot(panel=diabloPanel, omicName="mRNA.expr", database=database) +
  theme(legend.position = c(0.95,0.15)) + scale_color_manual(values=c("#000000", "#E69F00", "#56B4E9")) + 
  theme(legend.title = element_text(size=16), 
    legend.text = element_text(size=16), 
    plot.title = element_text(size=26, face = "bold"),
    axis.text.y = element_text(size = 7)) +
  # customTheme(sizeStripFont = 25, xAngle = 0.5, hjust = 0.5, vjust = 0.5,
  #             xSize = 15, ySize = 9, xAxisSize = 20, yAxisSize = 20) + 
  scale_x_continuous("", limits = c(0, 1), breaks = seq(0,1,0.2)) 
p1
p2 <- featurePlot(panel=diabloPanel, omicName="circRNA.expr", database=database) +
  theme(legend.position = c(0.95,0.15)) + ylab("") + scale_color_manual(values=c("#000000", "#0072B2")) + 
  theme(legend.title = element_text(size=16), 
    legend.text = element_text(size=16), 
    plot.title = element_text(size=26, face = "bold")) +
  theme(legend.title = element_text(size=16), 
    legend.text = element_text(size=16), 
    plot.title = element_text(size=26, face = "bold"),
    axis.text.y = element_text(size = 7)) +
  scale_x_continuous("", limits = c(0, 1), breaks = seq(0,1,0.2))
p2
p3 <- featurePlot(panel=diabloPanel, omicName="CpGs", database=database) +
  theme(legend.position = c(0.95,0.15)) + scale_color_manual(values=c("#000000", "#E69F00")) + 
  theme(legend.title = element_text(size=16), 
    legend.text = element_text(size=16), 
    plot.title = element_text(size=26, face = "bold")) +
  customTheme(sizeStripFont = 25, xAngle = 0.5, hjust = 0.5, vjust = 0.5,
              xSize = 15, ySize = 9, xAxisSize = 20, yAxisSize = 20) + 
  scale_x_continuous("Variable contributions \n absolute loadings", limits = c(0, 1), breaks = seq(0,1,0.2))
p4 <- featurePlot(panel=diabloPanel, omicName="Proteins", database=database) +
  theme(legend.position = c(0.95,0.2)) + ylab("") + scale_color_manual(values=c("#000000", "#CC79A7", "#E69F00", "#56B4E9", "#009E73", "#F0E442")) + 
  theme(legend.title = element_text(size=16), 
    legend.text = element_text(size=10), 
    plot.title = element_text(size=26, face = "bold")) +
  customTheme(sizeStripFont = 25, xAngle = 0.5, hjust = 0.5, vjust = 0.5,
              xSize = 15, ySize = 9, xAxisSize = 20, yAxisSize = 20) + 
  scale_x_continuous("Variable contributions \n absolute loadings", limits = c(0, 1), breaks = seq(0,1,0.2))
plot_grid(p1, p2, p3, p4, ncol = 2)
```

## Component plots

The plot below depicts the consensus and individual omics component plots based on the optimal biomarker panel, along with 95% confidence ellipses obtained from the training data and superimposed with the samples from the test data. The majority of the samples were within the ellipses, suggesting a reproducible multi-omics biomarker panel from the training to the test set, that was predictive of breast cancer subtypes (balanced error rate = 22.9%). The consensus plot corresponded strongly with the mRNA component plot, depicting a strong separation of the Basal (error rate = 4.9%) and Her2 (error rate = 20%) subtypes. We observed a weak separation of Luminal A (LumA, error rate = 13.3%) and Luminal B (LumB, error rate = 53.3%) subtypes. 

```{r SamplePlots_trainEllipses_testPoints, fig.path='Figures/', dev='png', fig.height=13, fig.width=10}
# model variates
varDat.train <- rbindlist(lapply(diablo$variates[1:length(X)], as.data.frame), use.names = T, 
                          idcol = "Dataset")
# %>% dplyr::mutate(subj = rownames(.))
varDat.train$subj <- rep(rownames(diablo$variates[1]$mut.status), e = 3)
varDat.train$Class <- Y[match(varDat.train$subj, names(Y))]
varDat.train <- varDat.train %>% dplyr::select(Dataset, comp1, comp2, comp3, subj, Class) %>% group_by(Class, subj) %>% 
  dplyr::summarise_all(funs(mean)) %>% 
  mutate(Dataset = "Consensus") %>% 
  dplyr::select(`comp1`, `comp2`, `comp3`, subj, Dataset, Class) %>% 
  as.data.frame() %>% 
  rbind(., varDat.train %>% dplyr::select(Dataset, comp1, comp2, comp3, subj, Class)) %>% 
  mutate(Dataset = factor(Dataset, c("Consensus", "mut.status", "mRNA.expr", "circRNA.expr"))) 
colnames(varDat.train) <- c("comp 1", "comp 2", "comp 3", "subj", "Dataset", "Class")

p1 <- filter(varDat.train, Dataset == "Consensus") %>% 
  ggplot(aes(x = `comp 1`, y = `comp 2`, color = Class)) + 
  geom_point(size = 2) +
  facet_wrap(~Dataset, scales = "free", ncol = 5) + 
   # stat_ellipse(data = filter(varDat.train, Dataset == "Consensus"), size = 1) +
  # customTheme(sizeStripFont = 25, xAngle = 0.5, hjust = 0.5, vjust = 0.5,
  #             xSize = 20, ySize = 20, xAxisSize = 20, yAxisSize = 20) +
  xlab("Component 1") + ylab("Component 2") + 
  theme(strip.text.x = element_text(size=26, face = "bold")) + 
  scale_color_manual(values=color.mixo(1:4)) +
  annotate("text", x = -1.5, y = -3.5, label = "Ellipses: training data \n points: test data", size =8)
p1
p2 <- filter(varDat.train, Dataset != "Consensus") %>% 
  ggplot(aes(x = `comp 1`, y = `comp 2`, color = Class)) + 
  geom_point(size = 2) +
  facet_wrap(~Dataset, scales = "free", ncol = 2) + 
   stat_ellipse(data = filter(varDat.train, Dataset != "Consensus"), size = 1) +
  # customTheme(sizeStripFont = 25, xAngle = 0.5, hjust = 0.5, vjust = 0.5,
  #             xSize = 20, ySize = 20, xAxisSize = 20, yAxisSize = 20) +
  xlab("Component 2") + ylab("Component 3") + 
  theme(strip.text.x = element_text(size=26, face = "bold")) + 
  scale_color_manual(values=color.mixo(1:4))
p2
plot_grid(p1, p2, ncol=1) 
# Y = as.factor(Y)
mixOmics::plotDiablo(diablo, ncomp = 1, col.per.group = c("#619CFF", "#F8766D"))
mixOmics::plotIndiv(diablo, ind.names = FALSE, legend = TRUE, 
          title = 'Sample Plots')
dev.off()
mixOmics::plotVar(diablo, var.names = F, comp = c(1,2),
        style = 'graphics', legend = TRUE,
        pch = c(16, 17, 15), cex = c(2,2,2), 
        col = c('darkorchid', 'brown1', 'lightgreen'))
diablo.plot = diablo
colnames(diablo.plot$X$mut.status) = paste0(colnames(diablo.plot$X$mut.status),"_mut")
rownames(diablo.plot$loadings$mut.status) = paste0(rownames(diablo.plot$loadings$mut.status), "_mut")
colnames(diablo.plot$X$circRNA.expr) = paste0("circ", gene_to_circ$gene_name[match(rownames(diablo.plot$loadings$circRNA.expr), gene_to_circ$circ_id)],"(", colnames(diablo.plot$X$circRNA.expr),")")
rownames(diablo.plot$loadings$circRNA.expr) = paste0("circ", gene_to_circ$gene_name[match(rownames(diablo.plot$loadings$circRNA.expr), gene_to_circ$circ_id)],"(", rownames(diablo.plot$loadings$circRNA.expr),")")
diablo.plot$keepX
sum(diablo.plot$loadings$mRNA.expr[,1]!=0)
png("/sharedfs01/alessia/TALL_MultiOmics/analysis/circosC123.png", width = 15, height = 15, units = "cm", res = 300)
mixOmics::circosPlot(object = diablo.plot, cutoff = 0.7,
                             line = TRUE, 
                             color.Y = c("#619CFF", "#F8766D"),
           color.blocks= c("#1F78B4", "#33A02C", "#E31A1C"),
           color.cor = c("chocolate3","grey20"), 
           size.labels = 1, comp = c(1:3), 
           size.variables = 0.000001)
dev.off()
NET = network(mat = diablo.plot, blocks = c(1,2,3), interactive = F, 
        color.node = c("#1F78B4", "#33A02C", "#E31A1C"), cutoff = 0.7)

mixOmics::plotLoadings(diablo.plot, comp = 1, contrib = 'max', method = 'median')
```

## Heatmap

Similarly, the heatmap showing the scaled expression of all features of the multi-omics biomarker panel, depicted a strong clustering of the Basal and Her2 samples whereas the Luminal A and B were mixed. 

```{r heatmap_brca, fig.path='Figures/', dev='png', fig.height=10, fig.width=8}
dev.off()
plot.new()
diablo.plot$loadings$mut.status[diablo.plot$loadings$mut.status[,1]!=0,]
mixOmics::cimDiablo(diablo.plot, comp = c(1,2,3,4,5), 
                    color.Y = c("#619CFF", "#F8766D"),
                    row.names = F, col.names = T, 
                    clust.method = c("ward.D", "ward.D"), transpose = T,
                    dist.method = c("correlation","correlation"),
                    row.cex = 0.4, col.cex = 0.2, keysize = c(1,1),
                    legend.position = "right", margins = c(2, 13), 
                    #save = "png", name.save = "varSelallC", 
                    size.legend = 1)
```

## Network

Overall, the features of the multi-omics biomarker panel formed a densely connected network comprising of four communities where variables in each community (cluster) were densely connected with themselves and sparsely connected with other clusters. 

```{r network_brca, fig.path='Figures/', dev='png', fig.height=8, fig.width=8}
corMat <- mapply(function(x, y){
  y[, x]
}, x = diabloPanel[c(1:3)], y = X, SIMPLIFY = FALSE) %>% 
  do.call(cbind, .) %>% 
  cor
colnames(corMat) <- rownames(corMat) <- paste(rep(names(diabloPanel)[1:3], sapply(diabloPanel[1:3], length)), colnames(corMat), sep="_")
corMat[lower.tri(corMat)] <- 0
diag(corMat) <- 0
color.blocks = brewer.pal(n = 12, name = "Paired")[seq(2, 12, by = 2)]
dim(corMat)
links <- corMat %>% 
  as.data.frame() %>% 
  dplyr::mutate(to = rownames(.)) %>% 
  gather(from, cor, -to) %>% 
  filter(abs(cor) > 0.45) %>% 
  mutate(Color = ifelse(cor > 0, "red", "blue"))
nodes <- data.frame(id = unique(c(links$to, links$from)))
nodes$datasets <- sapply(strsplit(as.character(nodes$id), "_"), function(i) i[1])
nodes$datasets = factor(nodes$datasets, levels = c("mut.status", "mRNA.expr", "circRNA.expr"))
net <- graph_from_data_frame(d=links, vertices=nodes, directed=FALSE) 
E(net)$color <- links$Color
V(net)$color <- color.blocks[as.numeric(nodes$datasets)]
E(net)$weight <- abs(links$cor)
weight <- E(net)$weight
# weight[weight == 0.4] <- 0.3
ceb <- cluster_edge_betweenness(graph = net) 
mark.groups <- split(as.character(nodes$id), factor(ceb$membership))
mark.groups <- mark.groups[sapply(mark.groups, length) > 3]
mark.col <- rainbow(length(mark.groups), alpha=.5)

net4 = subgraph(net, vids = mark.groups$`4`)
plot(net4, edge.curved=.5, vertex.label.cex=0.00000001, vertex.size=8, 
     # mark.groups=mark.groups, 
     # mark.col=mark.col, 
     vertex.label.color="black") 
legend("bottomleft", names(diabloPanel)[c(2,3,1)], col=unique(V(net)$color), 
       pch = 19, bty="n", cex = 1.5)
# saveRDS(net, "/sharedfs01/alessia/TALL_MultiOmics/networkSel045.rds")
# saveRDS(mark.groups, "/sharedfs01/alessia/TALL_MultiOmics/networkmarkG045.rds")

dt.net = rbindlist(lapply(mark.groups, data.frame), idcol="ColNet")
dt.net$SYMBOL = sapply(strsplit(as.character(dt.net$X..i..), "_"), function(i) i[2])
dt.net$datasets <- sapply(strsplit(as.character(dt.net$X..i..), "_"), function(i) i[1])
dt.net$SYMBOL[dt.net$datasets=="circRNA.expr"] = gene_to_circ$gene_name[match(dt.net$SYMBOL[dt.net$datasets=="circRNA.expr"],gene_to_circ$circ_id)]

dt.net[dt.net$ColNet==2,]
# write.csv(dt.net, "/sharedfs01/alessia/TALL_MultiOmics/analysis/netDT.csv")
# write.csv(links, "/sharedfs01/alessia/TALL_MultiOmics/analysis/linksDT.csv")
DataSel = data.frame(ID = sapply(strsplit(as.character(dt.net$X..i..), "_"), function(i) i[2]),
                     dataset = sapply(strsplit(as.character(dt.net$X..i..), "_"), function(i) i[1]))
mRNA_Sel_FC_CS1vsCS2 = mRNA_Mull %>% dplyr::filter(X%in%DataSel$ID[DataSel$dataset=="mRNA.expr"]) %>% melt() %>% merge(factors_data, by.x = "variable", by.y = "row.names") %>% group_by(X, cl) %>% dplyr::summarise(m = mean(value)) %>% spread(cl, m) %>% dplyr::mutate(logFC = log(`1` / `2`)) %>% dplyr::rename(SYMBOL=X)
circRNA_Sel_FC_CS1vsCS2 = circRNA_Mull %>% dplyr::filter(X%in%DataSel$ID[DataSel$dataset=="circRNA.expr"]) %>% melt() %>% merge(factors_data, by.x = "variable", by.y = "row.names") %>% group_by(X, cl) %>% dplyr::summarise(m = mean(value)) %>% spread(cl, m) %>% dplyr::mutate(logFC = log(`1` / `2`)) %>% dplyr::rename(SYMBOL=X)
circRNA_Sel_FC_CS1vsCS2$HG =  gene_to_circ$gene_name[match(circRNA_Sel_FC_CS1vsCS2$SYMBOL,gene_to_circ$circ_id)]
mut_Mull$X = rownames(mut_Mull)
mu_status = mut_Mull %>% melt() %>% merge(factors_data, by.x = "X", by.y = "row.names") %>% group_by(variable, cl) %>% summarise(n = sum(value), n.cl = n()) %>%
  mutate(freq = n / n.cl)
# write.csv(mRNA_Sel_FC_CS1vsCS2, "/sharedfs01/alessia/TALL_MultiOmics/analysis/mRNA_Sel_FC_CS1vsCS2.csv")
# write.csv(circRNA_Sel_FC_CS1vsCS2, "/sharedfs01/alessia/TALL_MultiOmics/analysis/circRNA_Sel_FC_CS1vsCS2.csv")
# write.csv(mu_status, "/sharedfs01/alessia/TALL_MultiOmics/analysis/Mstatus_CS1vsCS2.csv")
```

### Number of variables of each omic-type in the red cluster

```{r}
sapply(names(diabloPanel), function(i){
  length(grep(i, mark.groups$`4`))
})
```

## Geneset enrichment analysis

The largest cluster in the network consisted of 72 variables; 20 mRNAs, 21 miRNAs, 15 CpGs and 16 proteins (red bubble) and was further investigated using gene set enrichment analysis. We identified many cancer-associated pathways (e.g. FOXM1 pathway, p53 signaling pathway), DNA damage and repair pathways (e.g. E2F mediated regulation of DNA replication, G2M DNA damage checkpoint) and various cell-cycle pathways (e.g. G1S transition, mitotic G1/G1S phases), demonstrating the ability of DIABLO to identify a biologically plausible multi-omics biomarker panel. This panel generalized to new breast cancer samples and implicated previously unknown molecular features in breast cancer, which could be further validated in experimental studies. 

```{r genesetEnrichment_brca, fig.path='Figures/', dev='png', fig.height=7, fig.width=7}
## perform gene set enrichment analysis on each cluster of features
## intersection > 5 genes
library(sear)
input <- unlist(strsplit(sapply(strsplit(mark.groups[[1]], "_"), function(i) i[2]), ";"))
input <- dt.net$SYMBOL#[dt.net$datasets!="mut.status"]
input <- dt.net$SYMBOL[dt.net$ColNet==2 & dt.net$datasets!="mut.status"]
circD1 = rownames(diablo$loadings$circRNA.expr[diablo$loadings$circRNA.expr[,1]!=0,])
circHGD1 = gene_to_circ$gene_name[gene_to_circ$circ_id%in%circD1]
geneD1 = rownames(diablo.plot$loadings$mRNA.expr[diablo.plot$loadings$mRNA.expr[,1]!=0,])
mutD1 = rownames(diablo.plot$loadings$mut.status[diablo.plot$loadings$mut.status[,1]!=0,])
input = c(geneD1, circHGD1)
enrichment <- sear(input, "mrna") %>% 
    group_by(collection, subcollection) %>% 
    filter(fdr < 0.1, collection %in% c("C2")) %>% 
    filter(subcollection != "CGP")
enrichmentHM <- sear(input, "mrna") %>% 
    group_by(collection, subcollection) %>% 
    filter(fdr < 0.1, collection %in% c("H")) %>% 
    filter(subcollection != "CGP")
enrich.sign = input[input%in%enrichmentHM$members[enrichmentHM$geneset=="HALLMARK_MYC_TARGETS_V1"][[1]]]
enrich.sign = input[input%in%enrichment$members[enrichment$geneset=="KEGG_WNT_SIGNALING_PATHWAY"][[1]]]

net4 = subgraph(net, vids = dt.net[dt.net$SYMBOL%in%enrich.sign,]$X..i..)
plot(net4, edge.curved=.5, vertex.label.cex=1.5, vertex.size=8, 
     # mark.groups=mark.groups, 
     # mark.col=mark.col, 
     vertex.label.color="black") 
legend("bottomleft", names(diabloPanel)[c(2,3,1)], col=unique(V(net)$color), 
       pch = 19, bty="n", cex = 1.5)

dt.net[dt.net$X..i..%in%mark.groups$`4`,]
links.sign = links[links$to%in%dt.net[dt.net$SYMBOL%in%enrich.sign,]$X..i.. | links$from%in%dt.net[dt.net$SYMBOL%in%enrich.sign,]$X..i..,]
nodes.sign <- data.frame(id = unique(c(links.sign$to, links.sign$from)))
nodes.sign$datasets <- sapply(strsplit(as.character(nodes.sign$id), "_"), function(i) i[1])
nodes.sign$datasets = factor(nodes.sign$datasets, levels = c("mut.status", "mRNA.expr", "circRNA.expr"))
net.sign <- graph_from_data_frame(d=links.sign, directed=FALSE) 
E(net.sign)$color <- links.sign$Color
V(net.sign)$color <- color.blocks[as.numeric(nodes.sign$datasets)]
E(net.sign)$weight <- abs(links.wnt$cor)
weight <- E(net.sign)$weight
# weight[weight == 0.4] <- 0.3
ceb <- cluster_edge_betweenness(graph = net.sign) 
mark.groups <- split(as.character(nodes.sign$id), factor(ceb$membership))
mark.groups <- mark.groups[sapply(mark.groups, length) > 5]
mark.col <- rainbow(length(mark.groups), alpha=.5)
plot(net.sign, edge.curved=.5, vertex.label.cex=0.7, vertex.size=8, 
     mark.groups=mark.groups, 
     mark.col=mark.col, 
     vertex.label.color="black") 
legend("bottomleft", names(diabloPanel)[c(2,3,1)], col=unique(V(net)$color), 
       pch = 19, bty="n", cex = 1.5)


enrichment %>% ungroup %>% 
  mutate(geneset = tolower(sapply(strsplit(as.character(geneset), "_"), function(i) paste(i[-1], collapse=" ")))) %>% 
    arrange(desc(fdr)) %>% 
    mutate(geneset = factor(geneset, unique(geneset))) %>% 
  ggplot(aes(x = geneset, y = -log10(fdr), fill = subcollection, color = subcollection)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() +
  # customTheme(sizeStripFont = 15, xAngle = 0, hjust = 0.5, vjust = 0.5, 
  #   xSize = 20, ySize = 9, xAxisSize = 20, yAxisSize = 20) +
  theme_classic() + 
  theme(legend.position = c(0.61,0.3), 
        text = element_text(size=15)) +
  ylab(expression("-log"[10]~"FDR")) +
  xlab("Signficant Geneset at FDR=5%")

```


## Evaluate performance of diablo panel using additional data (test datasets)

```{r, results='hide'}
## Training data
Y.train <- droplevels(pam50Train0$Call)
names(Y.train) <- rownames(pam50Train0)
X.train <- list(mRNA = mrnaTrain0, miRNA = mirnaTrain0, CpGs = methTrain0, Proteins = protTrain0)
all(names(Y.train) == rownames(X.train[[1]]))
all(names(Y.train) == rownames(X.train[[2]]))
all(names(Y.train) == rownames(X.train[[3]]))
all(names(Y.train) == rownames(X.train[[4]]))
dim(X.train[[1]]); dim(X.train[[2]]); dim(X.train[[3]]); dim(X.train[[4]]);
## Test data
Y.test <- droplevels(pam50Test0$Call)
names(Y.test) <- rownames(pam50Test0)
length(c(Y.train, Y.test))
X.test <- list(mRNA = mrnaTest0, miRNA = mirnaTest0, CpGs = methTest0)
all(names(Y.test) == rownames(X.test[[1]]))
all(names(Y.test) == rownames(X.test[[2]]))
all(names(Y.test) == rownames(X.test[[3]]))
dim(X.test[[1]]); dim(X.test[[2]]); dim(X.test[[3]]); 
```

### Number of samples in the train and test datasets

```{r}
rbind(table(Y.train), table(Y.test)) %>% 
  as.data.frame %>% 
  mutate(Set = c("Train", "Test"))
```


## References
